;;; fuzzy chord analysis;; aka Chord-Catcher;;; determine root and flavor of chord;; requires fuzzy.lisp;; requires fuzzy_music.lisp;;;  root finder functions#|the fuzzy rules for determining rootfor all candidatesIf there is a note a third above the candidate it may be the rootIf there is a note a fifth above the candidate it may be the rootIf there is a note a seventh above the candidate it may be the rootIf a candidate is the lowest note in the chord, it may be the rootThe result set has twelve entries showing the score for all of the abovefor each pitch class. Higest score wins|#;; convert note numbers to pitch class(defun midi-list-to-PC-list (thelist)         (if (null thelist) ()             (cons (mod (first thelist) 12)                   (midi-list-to-pc-list (rest thelist)))))#| these are defined in fuzzy_music(defConstant *FZ-3* '(0 0 0 1 0.9 0 0 0 0 0 0 0))(defConstant *FZ-5* '(0 0 0 0 0 0 0.9 1 0.5 0 0 0))(defConstant *FZ-7* '(0 0 0 0 0 0 0 0 0 0 0.9 1))|#(defun 3rd-above-test (PC theChord)    (apply #'max (fz-intersect (ror-n *FZ-3* PC) theChord)))(defun 5th-above-test (PC theChord)    (apply #'max (fz-intersect (ror-n *FZ-5* PC) theChord)))(defun 7th-above-test (PC theChord)    (apply #'max (fz-intersect (ror-n *FZ-7* PC) theChord)));; combine these to keep code compact(defun test-intervals (p thechord)           (+ (3rd-above-test p thechord)              (5th-above-test p thechord)              (7th-above-test p thechord)));; the root finder(defun find-root-from-MIDI (midi-list)    (let* ((pc-list (midi-list-to-pc-list midi-list))           (pc-set (make-set pc-list))          (result-set (copy-list '(0 0 0 0 0 0 0 0 0 0 0 0)))          (lowest-pc (mod (apply #'min midi-list) 12)))      (dolist (p pc-list)        (setf (nth p result-set) (test-intervals p pc-set)))      (addto-n result-set lowest-pc 0.1)      ;(format t "~A ~%" result-set)      (ltop result-set)      ));(find-root-from-midi '(60 64 67));(find-root-from-midi '(61 64 68));(find-root-from-midi '(60 64 69));(find-root-from-midi '(61 64 69));(find-root-from-midi '(60 63 69));(find-root-from-midi '(62 66 70))#|;;;;;;;;;;;;;;;;;;;;;;;; type finderThe algorithm is to compare the chord set with templates for all knownchords on the root (aka brute force).Templates are show below. They will be tested in this order, becausecomplex chords contain simple ones.Comparisons are fuzzy:(fz-equal *dom7-chd* *maj7-chd*) ==> 5/6|#;;;;; Templates;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defconstant  *dom7-chd*  '(1 0 0 0 1 0 0 1 0 0 1 0)) ; key 0(defconstant  *m7b5-chd*  '( 1 0 0 1 0 0 1 0 0 0 1 0)) ; key 1(defconstant  *dim7-chd*  '(1 0 0 1 0 0 1 0 0 1 0 0)) ; key 2(defconstant   *maj7-chd*  '(1 0 0 0 1 0 0 1 0 0 0 1)) ; key 3(defconstant   *min7-chd*  '(1 0 0 1 0 0 0 1 0 0 1 0)) ; key 4(defconstant   *aug-chd*  '(1 0 0 0 1 0 0 0 1 0 0 0)) ; key 5(defconstant    *maj-chd* '(1 0 0 0 1 0 0 1 0 0 0 0)) ; key 6(defconstant   *min-chd*  '(1 0 0 1 0 0 0 1 0 0 0 0)) ; key 7(defconstant   *dim-chd*  '( 1 0 0 1 0 0 1 0 0 0 0 0)) ; key 8(defconstant   *min2-int* '( 1 1 0 0 0 0 0 0 0 0 0 0)) ; key 9(defconstant   *Maj2-int*  '(1 0 1 0 0 0 0 0 0 0 0 0)) ; key 10(defconstant   *min3-int*  '( 1 0 0 1 0 0 0 0 0 0 0 0)) ; key 11(defconstant   *Maj3-int*  '( 1 0 0 0 1 0 0 0 0 0 0 0)) ; key 12(defconstant   *P4-int*  '(1 0 0 0 0 1 0 0 0 0 0 0)) ; key 13(defconstant   *tt-int*  '( 1 0 0 0 0 0 1 0 0 0 0 0)) ; key 14(defconstant   *P5-int*  '(1 0 0 0 0 0 0 1 0 0 0 0)) ; key 15(defconstant   *min6-int* '( 1 0 0 0 0 0 0 0 1 0 0 0)) ; key 16(defconstant   *Maj6-int*  '( 1 0 0 0 0 0 0 0 0 1 0 0)) ; key 17(defconstant   *min7-int*  '( 1 0 0 0 0 0 0 0 0 0 1 0))  ; key 18(defconstant   *Maj7-int*  '( 1 0 0 0 0 0 0 0 0 0 0 1)) ; key 19(defconstant   *pitch* '(1 0 0 0 0 0 0 0 0 0 0 0)) ; key 20;; find the number of places that differ in two sets(defun fz-sum-compare (alist blist)      (if (or (null alist)(null blist)) 0          (+ (- 1 (abs (- (first alist)(first blist))))             (fz-sum-compare (rest alist)(rest blist)))));(fz-sum-compare *maj7-chd* *maj-chd*)==> 11; indicating 11 spots have the same value in both; fuzzy equality is matches/length(defun fz-equal (alist blist)      (/ (fz-sum-compare alist blist)         (min (length alist)(length blist))));(fz-equal *dom7-chd* *maj7-chd*);;;;; test a root position set agains all comers(defun guess-chord-type (root-pc chord-set)    (let ((testThis (ror-n chord-set (* -1 root-pc)))          (r-set (make-flat 21 0)))      ;(format t "~A ~A" testThis r-set)      (setf (nth  0 r-set) (fz-equal testThis *dom7-chd*))       (setf (nth  1 r-set) (fz-equal testThis *m7b5-chd*))       (setf (nth  2 r-set) (fz-equal testThis *dim7-chd*))       (setf (nth  3 r-set) (fz-equal testThis *maj7-chd*))       (setf (nth  4 r-set) (fz-equal testThis *min7-chd*))       (setf (nth  5 r-set) (fz-equal testThis *aug-chd*))       (setf (nth  6 r-set) (fz-equal testThis *maj-chd*))       (setf (nth  7 r-set) (fz-equal testThis *min-chd*))       (setf (nth  8 r-set) (fz-equal testThis *dim-chd*))       (setf (nth  9 r-set) (fz-equal testThis *min2-int*))       (setf (nth  10 r-set) (fz-equal testThis *maj2-int*))       (setf (nth  11 r-set) (fz-equal testThis *min3-int*))       (setf (nth  12 r-set) (fz-equal testThis *maj3-int*))       (setf (nth  13 r-set) (fz-equal testThis *P4-int*))       (setf (nth  14 r-set) (fz-equal testThis *tt-int*))       (setf (nth  15 r-set) (fz-equal testThis *P5-int*))       (setf (nth  16 r-set) (fz-equal testThis *min6-int*))       (setf (nth  17 r-set) (fz-equal testThis *maj6-int*))       (setf (nth  18 r-set) (fz-equal testThis *min7-int*))       (setf (nth  19 r-set) (fz-equal testThis *maj7-int*))       (setf (nth  20 r-set) (fz-equal testThis *pitch*))       (LTOP r-set)));(defvar testchordset (ror-n *min-chd* 3));(setq testchordset (ror-n *maj7-int* 3));(guess-chord-type 3 testchordset);; for the overall answer, find the root and use that to find the type (defun chord-root-and-type (midi-list)    (let* ((root (find-root-from-midi midi-list))          (pc-set (make-set (midi-list-to-pc-list midi-list)))          (chord-type (guess-chord-type root pc-set)))      (list root chord-type)));(chord-root-and-type '(60 64 67 ));(chord-root-and-type '(60 64 66 ));(chord-root-and-type '(61 64 66 ));(chord-root-and-type '(62 65 69 72))(defparameter *root-names* (list "C" "C#" "D" "D#" "E" "F" "F#" "G" "G#" "A" "A#" "B")) (defparameter *type-names*   (list "dom7-chd" "m7b5-chd" "dim7-chd"         "maj7-chd" "min7-chd" "aug-chd" "maj-chd"         "min-chd" "dim-chd" "min2-int" "maj2-int" "min3-int"        "maj3-int" "P4-int" "tt-int" "P5-int" "min6-int"        "maj6-int" "min7-int" "maj7-int" "pitch"))(defun post-chord-root-and-type (pc-list)  (let ((root-and-type (chord-root-and-type pc-list)))    (format t "~A ~A"             (nth (first root-and-type) *root-names*)            (nth (second root-and-type) *type-names*))))            ;(post-chord-root-and-type '(62 65 69 72)) 